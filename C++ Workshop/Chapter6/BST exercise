// Binary Search Tree of Classes exercise
//1. Start with a main func
//2. add a struct for numeric_tree
//3. add a variable named root. It is a pointer to numeric_tree
//4. add a function named add(). Takes int as an arguement and a pointer to pointer to the tree.
//5. add a function named delete_tree(). Implement this as a recursive function
//6. add a function named find(). Takes int as an arugment and a pointer to a pointer to the tree.
//7. add a recursive function named print()
//8. automate adding items using a FOR loop inside of main()
//9. print the newly constructed tree/s
//10. dyanmic data must be deleted after use.
// self-note: structure tree where 1 is in middle like 8, 6, 4, 2, 1, 3, 5, 7, 9,

#include <iostream>

struct numeric_tree {
    int value_;
    numeric_tree* left_;
    numeric_tree* right_;
};

numeric_tree* root = nullptr;

void add(int i, numeric_tree** tree) {
    if (*tree == nullptr) {
        numeric_tree* newtree = new numeric_tree;
        newtree->value_ = i;
        newtree->left_ = nullptr;
        newtree->right_ = nullptr;
        *tree = newtree;
    }
    else if (i % 2 == 0) {
        add(i, &((*tree)->left_));
    }
    else {
        add(i, &((*tree)->right_));
    }
}

void delete_tree(numeric_tree** tree) {
    if (*tree == nullptr) {
        return;
    }
    delete_tree(&((*tree)->left_));
    delete_tree(&((*tree)->right_));
    std::cout << "numeric Tree: " << (*tree)->value_ << " has been deleted." << std::endl;
    delete *tree;
    *tree = nullptr;
}

numeric_tree** find(int i, numeric_tree** tree) {
    if (*tree == nullptr) {
        return tree;
    }
    else if (i < (*tree)->value_) {
        return find(i, &((*tree)->left_));
    }
    else {
        return find(i, &((*tree)->right_));
    }
}

void print(numeric_tree* tree) {
    if (tree == nullptr) {
        return;
    }
    print(tree->left_);
    std::cout << tree->value_ << " "; 
    print(tree->right_);
}

int main() {
    for (int i = 1; i < 10; i = i + 1) {
        add(i, &root);
    }
    print(root);
    delete_tree(&root);
}
